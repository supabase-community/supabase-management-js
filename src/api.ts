/**
 * This file is auto-generated by scripts/generate-class.mjs.
 * Do not edit manually - re-run `npm run generate:client` to update.
 */
import {
  v1ActivateCustomHostname,
  v1ActivateVanitySubdomainConfig,
  v1ApplyAMigration,
  v1ApplyProjectAddon,
  v1AuthorizeJitAccess,
  v1AuthorizeUser,
  v1BulkCreateSecrets,
  v1BulkDeleteSecrets,
  v1BulkUpdateFunctions,
  v1CancelAProjectRestoration,
  v1CheckVanitySubdomainAvailability,
  v1ClaimProjectForOrganization,
  v1CountActionRuns,
  v1CreateABranch,
  v1CreateAFunctionWithApplicationVndDenolandEszip,
  v1CreateAFunctionWithJson,
  v1CreateAProject,
  v1CreateASsoProvider,
  v1CreateAnOrganization,
  v1CreateLegacySigningKey,
  v1CreateLoginRole,
  v1CreateProjectApiKey,
  v1CreateProjectClaimToken,
  v1CreateProjectSigningKey,
  v1CreateProjectTpaIntegration,
  v1CreateRestorePoint,
  v1DeactivateVanitySubdomainConfig,
  v1DeleteABranch,
  v1DeleteAFunction,
  v1DeleteAProject,
  v1DeleteASsoProvider,
  v1DeleteHostnameConfig,
  v1DeleteJitAccess,
  v1DeleteLoginRoles,
  v1DeleteNetworkBans,
  v1DeleteProjectApiKey,
  v1DeleteProjectClaimToken,
  v1DeleteProjectTpaIntegration,
  v1DeployAFunction,
  v1DiffABranch,
  v1DisablePreviewBranching,
  v1DisableReadonlyModeTemporarily,
  v1EnableDatabaseWebhook,
  v1ExchangeOauthToken,
  v1GenerateTypescriptTypes,
  v1GetABranch,
  v1GetABranchConfig,
  v1GetAFunction,
  v1GetAFunctionBody,
  v1GetAMigration,
  v1GetASnippet,
  v1GetASsoProvider,
  v1GetActionRun,
  v1GetActionRunLogs,
  v1GetAllProjectsForOrganization,
  v1GetAnOrganization,
  v1GetAuthServiceConfig,
  v1GetAvailableRegions,
  v1GetDatabaseMetadata,
  v1GetDiskUtilization,
  v1GetHostnameConfig,
  v1GetJitAccess,
  v1GetJitAccessConfig,
  v1GetLegacySigningKey,
  v1GetNetworkRestrictions,
  v1GetOrganizationProjectClaim,
  v1GetPerformanceAdvisors,
  v1GetPgsodiumConfig,
  v1GetPoolerConfig,
  v1GetPostgresConfig,
  v1GetPostgresUpgradeEligibility,
  v1GetPostgresUpgradeStatus,
  v1GetPostgrestServiceConfig,
  v1GetProject,
  v1GetProjectApiKey,
  v1GetProjectApiKeys,
  v1GetProjectClaimToken,
  v1GetProjectDiskAutoscaleConfig,
  v1GetProjectFunctionCombinedStats,
  v1GetProjectLegacyApiKeys,
  v1GetProjectLogs,
  v1GetProjectPgbouncerConfig,
  v1GetProjectSigningKey,
  v1GetProjectSigningKeys,
  v1GetProjectTpaIntegration,
  v1GetProjectUsageApiCount,
  v1GetProjectUsageRequestCount,
  v1GetReadonlyModeStatus,
  v1GetRealtimeConfig,
  v1GetRestorePoint,
  v1GetSecurityAdvisors,
  v1GetServicesHealth,
  v1GetSslEnforcementConfig,
  v1GetStorageConfig,
  v1GetVanitySubdomainConfig,
  v1ListActionRuns,
  v1ListAllBackups,
  v1ListAllBranches,
  v1ListAllBuckets,
  v1ListAllFunctions,
  v1ListAllNetworkBans,
  v1ListAllNetworkBansEnriched,
  v1ListAllOrganizations,
  v1ListAllProjects,
  v1ListAllSecrets,
  v1ListAllSnippets,
  v1ListAllSsoProvider,
  v1ListAvailableRestoreVersions,
  v1ListJitAccess,
  v1ListMigrationHistory,
  v1ListOrganizationMembers,
  v1ListProjectAddons,
  v1ListProjectTpaIntegrations,
  v1MergeABranch,
  v1ModifyDatabaseDisk,
  v1OauthAuthorizeProjectClaim,
  v1PatchAMigration,
  v1PatchNetworkRestrictions,
  v1PauseAProject,
  v1PushABranch,
  v1ReadOnlyQuery,
  v1RemoveAReadReplica,
  v1RemoveProjectAddon,
  v1RemoveProjectSigningKey,
  v1ResetABranch,
  v1RestoreABranch,
  v1RestoreAProject,
  v1RestorePitrBackup,
  v1RevokeToken,
  v1RollbackMigrations,
  v1RunAQuery,
  v1SetupAReadReplica,
  v1ShutdownRealtime,
  v1Undo,
  v1UpdateABranchConfig,
  v1UpdateAFunctionWithApplicationVndDenolandEszip,
  v1UpdateAFunctionWithJson,
  v1UpdateAProject,
  v1UpdateASsoProvider,
  v1UpdateActionRunStatus,
  v1UpdateAuthServiceConfig,
  v1UpdateDatabasePassword,
  v1UpdateHostnameConfig,
  v1UpdateJitAccess,
  v1UpdateJitAccessConfig,
  v1UpdateNetworkRestrictions,
  v1UpdatePgsodiumConfig,
  v1UpdatePoolerConfig,
  v1UpdatePostgresConfig,
  v1UpdatePostgrestServiceConfig,
  v1UpdateProjectApiKey,
  v1UpdateProjectLegacyApiKeys,
  v1UpdateProjectSigningKey,
  v1UpdateRealtimeConfig,
  v1UpdateSslEnforcementConfig,
  v1UpdateStorageConfig,
  v1UpgradePostgresVersion,
  v1UpsertAMigration,
  v1VerifyDnsConfig,
} from './generated';

import type {
  ApplyProjectAddonBody,
  AuthorizeJitAccessBody,
  BranchActionBody,
  BulkUpdateFunctionBody,
  CreateApiKeyBody,
  CreateBranchBody,
  CreateOrganizationV1,
  CreateProviderBody,
  CreateRoleBody,
  CreateSecretBody,
  CreateSigningKeyBody,
  CreateThirdPartyAuthBody,
  DeleteSecretsBody,
  DiskRequestBody,
  FunctionDeployBody,
  JitAccessRequestRequest,
  NetworkRestrictionsPatchRequest,
  NetworkRestrictionsRequest,
  OAuthRevokeTokenBody,
  OAuthTokenBody,
  RemoveNetworkBanRequest,
  RemoveReadReplicaBody,
  SetUpReadReplicaBody,
  SslEnforcementRequest,
  UpdateApiKeyBody,
  UpdateAuthConfigBody,
  UpdateBranchBody,
  UpdateCustomHostnameBody,
  UpdateJitAccessBody,
  UpdatePgsodiumConfigBody,
  UpdatePostgresConfigBody,
  UpdateProviderBody,
  UpdateRealtimeConfigBody,
  UpdateRunStatusBody,
  UpdateSigningKeyBody,
  UpdateStorageConfigBody,
  UpdateSupavisorConfigBody,
  UpgradeDatabaseBody,
  V1AuthorizeUserParams,
  V1CreateAFunctionWithApplicationVndDenolandEszipParams,
  V1CreateAFunctionWithJsonParams,
  V1CreateFunctionBody,
  V1CreateMigrationBody,
  V1CreateProjectApiKeyParams,
  V1CreateProjectBody,
  V1DeleteABranchParams,
  V1DeleteProjectApiKeyParams,
  V1DeployAFunctionParams,
  V1DiffABranchParams,
  V1GenerateTypescriptTypesParams,
  V1GetAllProjectsForOrganizationParams,
  V1GetAvailableRegionsParams,
  V1GetPostgresUpgradeStatusParams,
  V1GetProjectApiKeyParams,
  V1GetProjectApiKeysParams,
  V1GetProjectFunctionCombinedStatsParams,
  V1GetProjectLogsParams,
  V1GetProjectUsageApiCountParams,
  V1GetRestorePointParams,
  V1GetSecurityAdvisorsParams,
  V1GetServicesHealthParams,
  V1ListActionRunsParams,
  V1ListAllSnippetsParams,
  V1OauthAuthorizeProjectClaimParams,
  V1PatchMigrationBody,
  V1ReadOnlyQueryBody,
  V1RestorePitrBody,
  V1RestorePointPostBody,
  V1RollbackMigrationsParams,
  V1RunQueryBody,
  V1UndoBody,
  V1UpdateAFunctionWithApplicationVndDenolandEszipParams,
  V1UpdateAFunctionWithJsonParams,
  V1UpdateFunctionBody,
  V1UpdatePasswordBody,
  V1UpdatePostgrestConfigBody,
  V1UpdateProjectApiKeyParams,
  V1UpdateProjectBody,
  V1UpdateProjectLegacyApiKeysParams,
  V1UpsertMigrationBody,
  VanitySubdomainBody,
  v1ActivateCustomHostnameResponseSuccess,
  v1ActivateVanitySubdomainConfigResponseSuccess,
  v1ApplyAMigrationResponseSuccess,
  v1ApplyProjectAddonResponseSuccess,
  v1AuthorizeJitAccessResponseSuccess,
  v1AuthorizeUserResponseSuccess,
  v1BulkCreateSecretsResponseSuccess,
  v1BulkDeleteSecretsResponseSuccess,
  v1BulkUpdateFunctionsResponseSuccess,
  v1CancelAProjectRestorationResponseSuccess,
  v1CheckVanitySubdomainAvailabilityResponseSuccess,
  v1ClaimProjectForOrganizationResponseSuccess,
  v1CountActionRunsResponseSuccess,
  v1CreateABranchResponseSuccess,
  v1CreateAFunctionWithApplicationVndDenolandEszipResponseSuccess,
  v1CreateAFunctionWithJsonResponseSuccess,
  v1CreateAProjectResponseSuccess,
  v1CreateASsoProviderResponseSuccess,
  v1CreateAnOrganizationResponseSuccess,
  v1CreateLegacySigningKeyResponseSuccess,
  v1CreateLoginRoleResponseSuccess,
  v1CreateProjectApiKeyResponseSuccess,
  v1CreateProjectClaimTokenResponseSuccess,
  v1CreateProjectSigningKeyResponseSuccess,
  v1CreateProjectTpaIntegrationResponseSuccess,
  v1CreateRestorePointResponseSuccess,
  v1DeactivateVanitySubdomainConfigResponseSuccess,
  v1DeleteABranchResponseSuccess,
  v1DeleteAFunctionResponseSuccess,
  v1DeleteAProjectResponseSuccess,
  v1DeleteASsoProviderResponseSuccess,
  v1DeleteHostnameConfigResponseSuccess,
  v1DeleteJitAccessResponseSuccess,
  v1DeleteLoginRolesResponseSuccess,
  v1DeleteNetworkBansResponseSuccess,
  v1DeleteProjectApiKeyResponseSuccess,
  v1DeleteProjectClaimTokenResponseSuccess,
  v1DeleteProjectTpaIntegrationResponseSuccess,
  v1DeployAFunctionResponseSuccess,
  v1DiffABranchResponseSuccess,
  v1DisablePreviewBranchingResponseSuccess,
  v1DisableReadonlyModeTemporarilyResponseSuccess,
  v1EnableDatabaseWebhookResponseSuccess,
  v1ExchangeOauthTokenResponseSuccess,
  v1GenerateTypescriptTypesResponseSuccess,
  v1GetABranchConfigResponseSuccess,
  v1GetABranchResponseSuccess,
  v1GetAFunctionBodyResponseSuccess,
  v1GetAFunctionResponseSuccess,
  v1GetAMigrationResponseSuccess,
  v1GetASnippetResponseSuccess,
  v1GetASsoProviderResponseSuccess,
  v1GetActionRunLogsResponseSuccess,
  v1GetActionRunResponseSuccess,
  v1GetAllProjectsForOrganizationResponseSuccess,
  v1GetAnOrganizationResponseSuccess,
  v1GetAuthServiceConfigResponseSuccess,
  v1GetAvailableRegionsResponseSuccess,
  v1GetDatabaseMetadataResponseSuccess,
  v1GetDiskUtilizationResponseSuccess,
  v1GetHostnameConfigResponseSuccess,
  v1GetJitAccessConfigResponseSuccess,
  v1GetJitAccessResponseSuccess,
  v1GetLegacySigningKeyResponseSuccess,
  v1GetNetworkRestrictionsResponseSuccess,
  v1GetOrganizationProjectClaimResponseSuccess,
  v1GetPerformanceAdvisorsResponseSuccess,
  v1GetPgsodiumConfigResponseSuccess,
  v1GetPoolerConfigResponseSuccess,
  v1GetPostgresConfigResponseSuccess,
  v1GetPostgresUpgradeEligibilityResponseSuccess,
  v1GetPostgresUpgradeStatusResponseSuccess,
  v1GetPostgrestServiceConfigResponseSuccess,
  v1GetProjectApiKeyResponseSuccess,
  v1GetProjectApiKeysResponseSuccess,
  v1GetProjectClaimTokenResponseSuccess,
  v1GetProjectDiskAutoscaleConfigResponseSuccess,
  v1GetProjectFunctionCombinedStatsResponseSuccess,
  v1GetProjectLegacyApiKeysResponseSuccess,
  v1GetProjectLogsResponseSuccess,
  v1GetProjectPgbouncerConfigResponseSuccess,
  v1GetProjectResponseSuccess,
  v1GetProjectSigningKeyResponseSuccess,
  v1GetProjectSigningKeysResponseSuccess,
  v1GetProjectTpaIntegrationResponseSuccess,
  v1GetProjectUsageApiCountResponseSuccess,
  v1GetProjectUsageRequestCountResponseSuccess,
  v1GetReadonlyModeStatusResponseSuccess,
  v1GetRealtimeConfigResponseSuccess,
  v1GetRestorePointResponseSuccess,
  v1GetSecurityAdvisorsResponseSuccess,
  v1GetServicesHealthResponseSuccess,
  v1GetSslEnforcementConfigResponseSuccess,
  v1GetStorageConfigResponseSuccess,
  v1GetVanitySubdomainConfigResponseSuccess,
  v1ListActionRunsResponseSuccess,
  v1ListAllBackupsResponseSuccess,
  v1ListAllBranchesResponseSuccess,
  v1ListAllBucketsResponseSuccess,
  v1ListAllFunctionsResponseSuccess,
  v1ListAllNetworkBansEnrichedResponseSuccess,
  v1ListAllNetworkBansResponseSuccess,
  v1ListAllOrganizationsResponseSuccess,
  v1ListAllProjectsResponseSuccess,
  v1ListAllSecretsResponseSuccess,
  v1ListAllSnippetsResponseSuccess,
  v1ListAllSsoProviderResponseSuccess,
  v1ListAvailableRestoreVersionsResponseSuccess,
  v1ListJitAccessResponseSuccess,
  v1ListMigrationHistoryResponseSuccess,
  v1ListOrganizationMembersResponseSuccess,
  v1ListProjectAddonsResponseSuccess,
  v1ListProjectTpaIntegrationsResponseSuccess,
  v1MergeABranchResponseSuccess,
  v1ModifyDatabaseDiskResponseSuccess,
  v1OauthAuthorizeProjectClaimResponseSuccess,
  v1PatchAMigrationResponseSuccess,
  v1PatchNetworkRestrictionsResponseSuccess,
  v1PauseAProjectResponseSuccess,
  v1PushABranchResponseSuccess,
  v1ReadOnlyQueryResponseSuccess,
  v1RemoveAReadReplicaResponseSuccess,
  v1RemoveProjectAddonResponseSuccess,
  v1RemoveProjectSigningKeyResponseSuccess,
  v1ResetABranchResponseSuccess,
  v1RestoreABranchResponseSuccess,
  v1RestoreAProjectResponseSuccess,
  v1RestorePitrBackupResponseSuccess,
  v1RevokeTokenResponseSuccess,
  v1RollbackMigrationsResponseSuccess,
  v1RunAQueryResponseSuccess,
  v1SetupAReadReplicaResponseSuccess,
  v1ShutdownRealtimeResponseSuccess,
  v1UndoResponseSuccess,
  v1UpdateABranchConfigResponseSuccess,
  v1UpdateAFunctionWithApplicationVndDenolandEszipResponseSuccess,
  v1UpdateAFunctionWithJsonResponseSuccess,
  v1UpdateAProjectResponseSuccess,
  v1UpdateASsoProviderResponseSuccess,
  v1UpdateActionRunStatusResponseSuccess,
  v1UpdateAuthServiceConfigResponseSuccess,
  v1UpdateDatabasePasswordResponseSuccess,
  v1UpdateHostnameConfigResponseSuccess,
  v1UpdateJitAccessConfigResponseSuccess,
  v1UpdateJitAccessResponseSuccess,
  v1UpdateNetworkRestrictionsResponseSuccess,
  v1UpdatePgsodiumConfigResponseSuccess,
  v1UpdatePoolerConfigResponseSuccess,
  v1UpdatePostgresConfigResponseSuccess,
  v1UpdatePostgrestServiceConfigResponseSuccess,
  v1UpdateProjectApiKeyResponseSuccess,
  v1UpdateProjectLegacyApiKeysResponseSuccess,
  v1UpdateProjectSigningKeyResponseSuccess,
  v1UpdateRealtimeConfigResponseSuccess,
  v1UpdateSslEnforcementConfigResponseSuccess,
  v1UpdateStorageConfigResponseSuccess,
  v1UpgradePostgresVersionResponseSuccess,
  v1UpsertAMigrationResponseSuccess,
  v1VerifyDnsConfigResponseSuccess,
} from './generated';

import { SupabaseManagementAPIError } from './error';

export interface SupabaseManagementAPIOptions {
  accessToken: string;
  baseUrl?: string;
}

export class SupabaseManagementAPI {
  private readonly accessToken: string;
  private readonly baseUrl: string;

  constructor({ accessToken, baseUrl = 'https://api.supabase.com' }: SupabaseManagementAPIOptions) {
    this.accessToken = accessToken;
    this.baseUrl = baseUrl;
  }

  private get authHeader(): HeadersInit {
    return { Authorization: `Bearer ${this.accessToken}` };
  }

  async getPerformanceAdvisors(ref: string, options?: RequestInit): Promise<v1GetPerformanceAdvisorsResponseSuccess> {
    const result = await v1GetPerformanceAdvisors(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getPerformanceAdvisors');
    }
    return result as v1GetPerformanceAdvisorsResponseSuccess;
  }

  async getSecurityAdvisors(ref: string, params?: V1GetSecurityAdvisorsParams, options?: RequestInit): Promise<v1GetSecurityAdvisorsResponseSuccess> {
    const result = await v1GetSecurityAdvisors(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getSecurityAdvisors');
    }
    return result as v1GetSecurityAdvisorsResponseSuccess;
  }

  async getProjectLogs(ref: string, params?: V1GetProjectLogsParams, options?: RequestInit): Promise<v1GetProjectLogsResponseSuccess> {
    const result = await v1GetProjectLogs(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectLogs');
    }
    return result as v1GetProjectLogsResponseSuccess;
  }

  async getProjectUsageApiCount(ref: string, params?: V1GetProjectUsageApiCountParams, options?: RequestInit): Promise<v1GetProjectUsageApiCountResponseSuccess> {
    const result = await v1GetProjectUsageApiCount(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectUsageApiCount');
    }
    return result as v1GetProjectUsageApiCountResponseSuccess;
  }

  async getProjectUsageRequestCount(ref: string, options?: RequestInit): Promise<v1GetProjectUsageRequestCountResponseSuccess> {
    const result = await v1GetProjectUsageRequestCount(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectUsageRequestCount');
    }
    return result as v1GetProjectUsageRequestCountResponseSuccess;
  }

  async getProjectFunctionCombinedStats(ref: string, params: V1GetProjectFunctionCombinedStatsParams, options?: RequestInit): Promise<v1GetProjectFunctionCombinedStatsResponseSuccess> {
    const result = await v1GetProjectFunctionCombinedStats(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectFunctionCombinedStats');
    }
    return result as v1GetProjectFunctionCombinedStatsResponseSuccess;
  }

  async createLegacySigningKey(ref: string, options?: RequestInit): Promise<v1CreateLegacySigningKeyResponseSuccess> {
    const result = await v1CreateLegacySigningKey(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createLegacySigningKey');
    }
    return result as v1CreateLegacySigningKeyResponseSuccess;
  }

  async getLegacySigningKey(ref: string, options?: RequestInit): Promise<v1GetLegacySigningKeyResponseSuccess> {
    const result = await v1GetLegacySigningKey(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getLegacySigningKey');
    }
    return result as v1GetLegacySigningKeyResponseSuccess;
  }

  async createProjectSigningKey(ref: string, createSigningKeyBody: CreateSigningKeyBody, options?: RequestInit): Promise<v1CreateProjectSigningKeyResponseSuccess> {
    const result = await v1CreateProjectSigningKey(ref, createSigningKeyBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createProjectSigningKey');
    }
    return result as v1CreateProjectSigningKeyResponseSuccess;
  }

  async getProjectSigningKeys(ref: string, options?: RequestInit): Promise<v1GetProjectSigningKeysResponseSuccess> {
    const result = await v1GetProjectSigningKeys(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectSigningKeys');
    }
    return result as v1GetProjectSigningKeysResponseSuccess;
  }

  async getProjectSigningKey(ref: string, id: string, options?: RequestInit): Promise<v1GetProjectSigningKeyResponseSuccess> {
    const result = await v1GetProjectSigningKey(ref, id, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectSigningKey');
    }
    return result as v1GetProjectSigningKeyResponseSuccess;
  }

  async removeProjectSigningKey(ref: string, id: string, options?: RequestInit): Promise<v1RemoveProjectSigningKeyResponseSuccess> {
    const result = await v1RemoveProjectSigningKey(ref, id, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'removeProjectSigningKey');
    }
    return result as v1RemoveProjectSigningKeyResponseSuccess;
  }

  async updateProjectSigningKey(ref: string, id: string, updateSigningKeyBody: UpdateSigningKeyBody, options?: RequestInit): Promise<v1UpdateProjectSigningKeyResponseSuccess> {
    const result = await v1UpdateProjectSigningKey(ref, id, updateSigningKeyBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateProjectSigningKey');
    }
    return result as v1UpdateProjectSigningKeyResponseSuccess;
  }

  async getAuthServiceConfig(ref: string, options?: RequestInit): Promise<v1GetAuthServiceConfigResponseSuccess> {
    const result = await v1GetAuthServiceConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getAuthServiceConfig');
    }
    return result as v1GetAuthServiceConfigResponseSuccess;
  }

  async updateAuthServiceConfig(ref: string, updateAuthConfigBody: UpdateAuthConfigBody, options?: RequestInit): Promise<v1UpdateAuthServiceConfigResponseSuccess> {
    const result = await v1UpdateAuthServiceConfig(ref, updateAuthConfigBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateAuthServiceConfig');
    }
    return result as v1UpdateAuthServiceConfigResponseSuccess;
  }

  async createProjectTpaIntegration(ref: string, createThirdPartyAuthBody: CreateThirdPartyAuthBody, options?: RequestInit): Promise<v1CreateProjectTpaIntegrationResponseSuccess> {
    const result = await v1CreateProjectTpaIntegration(ref, createThirdPartyAuthBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createProjectTpaIntegration');
    }
    return result as v1CreateProjectTpaIntegrationResponseSuccess;
  }

  async listProjectTpaIntegrations(ref: string, options?: RequestInit): Promise<v1ListProjectTpaIntegrationsResponseSuccess> {
    const result = await v1ListProjectTpaIntegrations(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listProjectTpaIntegrations');
    }
    return result as v1ListProjectTpaIntegrationsResponseSuccess;
  }

  async deleteProjectTpaIntegration(ref: string, tpaId: string, options?: RequestInit): Promise<v1DeleteProjectTpaIntegrationResponseSuccess> {
    const result = await v1DeleteProjectTpaIntegration(ref, tpaId, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteProjectTpaIntegration');
    }
    return result as v1DeleteProjectTpaIntegrationResponseSuccess;
  }

  async getProjectTpaIntegration(ref: string, tpaId: string, options?: RequestInit): Promise<v1GetProjectTpaIntegrationResponseSuccess> {
    const result = await v1GetProjectTpaIntegration(ref, tpaId, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectTpaIntegration');
    }
    return result as v1GetProjectTpaIntegrationResponseSuccess;
  }

  async createASsoProvider(ref: string, createProviderBody: CreateProviderBody, options?: RequestInit): Promise<v1CreateASsoProviderResponseSuccess> {
    const result = await v1CreateASsoProvider(ref, createProviderBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createASsoProvider');
    }
    return result as v1CreateASsoProviderResponseSuccess;
  }

  async listAllSsoProvider(ref: string, options?: RequestInit): Promise<v1ListAllSsoProviderResponseSuccess> {
    const result = await v1ListAllSsoProvider(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllSsoProvider');
    }
    return result as v1ListAllSsoProviderResponseSuccess;
  }

  async getASsoProvider(ref: string, providerId: string, options?: RequestInit): Promise<v1GetASsoProviderResponseSuccess> {
    const result = await v1GetASsoProvider(ref, providerId, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getASsoProvider');
    }
    return result as v1GetASsoProviderResponseSuccess;
  }

  async updateASsoProvider(ref: string, providerId: string, updateProviderBody: UpdateProviderBody, options?: RequestInit): Promise<v1UpdateASsoProviderResponseSuccess> {
    const result = await v1UpdateASsoProvider(ref, providerId, updateProviderBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateASsoProvider');
    }
    return result as v1UpdateASsoProviderResponseSuccess;
  }

  async deleteASsoProvider(ref: string, providerId: string, options?: RequestInit): Promise<v1DeleteASsoProviderResponseSuccess> {
    const result = await v1DeleteASsoProvider(ref, providerId, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteASsoProvider');
    }
    return result as v1DeleteASsoProviderResponseSuccess;
  }

  async listProjectAddons(ref: string, options?: RequestInit): Promise<v1ListProjectAddonsResponseSuccess> {
    const result = await v1ListProjectAddons(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listProjectAddons');
    }
    return result as v1ListProjectAddonsResponseSuccess;
  }

  async applyProjectAddon(ref: string, applyProjectAddonBody: ApplyProjectAddonBody, options?: RequestInit): Promise<v1ApplyProjectAddonResponseSuccess> {
    const result = await v1ApplyProjectAddon(ref, applyProjectAddonBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'applyProjectAddon');
    }
    return result as v1ApplyProjectAddonResponseSuccess;
  }

  async removeProjectAddon(ref: string, addonVariant: 'ci_micro' | 'ci_small' | 'ci_medium' | 'ci_large' | 'ci_xlarge' | 'ci_2xlarge' | 'ci_4xlarge' | 'ci_8xlarge' | 'ci_12xlarge' | 'ci_16xlarge' | 'ci_24xlarge' | 'ci_24xlarge_optimized_cpu' | 'ci_24xlarge_optimized_memory' | 'ci_24xlarge_high_memory' | 'ci_48xlarge' | 'ci_48xlarge_optimized_cpu' | 'ci_48xlarge_optimized_memory' | 'ci_48xlarge_high_memory' | 'cd_default' | 'pitr_7' | 'pitr_14' | 'pitr_28' | 'ipv4_default', options?: RequestInit): Promise<v1RemoveProjectAddonResponseSuccess> {
    const result = await v1RemoveProjectAddon(ref, addonVariant, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'removeProjectAddon');
    }
    return result as v1RemoveProjectAddonResponseSuccess;
  }

  async listAllSnippets(params?: V1ListAllSnippetsParams, options?: RequestInit): Promise<v1ListAllSnippetsResponseSuccess> {
    const result = await v1ListAllSnippets(params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllSnippets');
    }
    return result as v1ListAllSnippetsResponseSuccess;
  }

  async getASnippet(id: string, options?: RequestInit): Promise<v1GetASnippetResponseSuccess> {
    const result = await v1GetASnippet(id, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getASnippet');
    }
    return result as v1GetASnippetResponseSuccess;
  }

  async getJitAccessConfig(ref: string, options?: RequestInit): Promise<v1GetJitAccessConfigResponseSuccess> {
    const result = await v1GetJitAccessConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getJitAccessConfig');
    }
    return result as v1GetJitAccessConfigResponseSuccess;
  }

  async updateJitAccessConfig(ref: string, jitAccessRequestRequest: JitAccessRequestRequest, options?: RequestInit): Promise<v1UpdateJitAccessConfigResponseSuccess> {
    const result = await v1UpdateJitAccessConfig(ref, jitAccessRequestRequest, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateJitAccessConfig');
    }
    return result as v1UpdateJitAccessConfigResponseSuccess;
  }

  async getSslEnforcementConfig(ref: string, options?: RequestInit): Promise<v1GetSslEnforcementConfigResponseSuccess> {
    const result = await v1GetSslEnforcementConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getSslEnforcementConfig');
    }
    return result as v1GetSslEnforcementConfigResponseSuccess;
  }

  async updateSslEnforcementConfig(ref: string, sslEnforcementRequest: SslEnforcementRequest, options?: RequestInit): Promise<v1UpdateSslEnforcementConfigResponseSuccess> {
    const result = await v1UpdateSslEnforcementConfig(ref, sslEnforcementRequest, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateSslEnforcementConfig');
    }
    return result as v1UpdateSslEnforcementConfigResponseSuccess;
  }

  async generateTypescriptTypes(ref: string, params?: V1GenerateTypescriptTypesParams, options?: RequestInit): Promise<v1GenerateTypescriptTypesResponseSuccess> {
    const result = await v1GenerateTypescriptTypes(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'generateTypescriptTypes');
    }
    return result as v1GenerateTypescriptTypesResponseSuccess;
  }

  async getReadonlyModeStatus(ref: string, options?: RequestInit): Promise<v1GetReadonlyModeStatusResponseSuccess> {
    const result = await v1GetReadonlyModeStatus(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getReadonlyModeStatus');
    }
    return result as v1GetReadonlyModeStatusResponseSuccess;
  }

  async disableReadonlyModeTemporarily(ref: string, options?: RequestInit): Promise<v1DisableReadonlyModeTemporarilyResponseSuccess> {
    const result = await v1DisableReadonlyModeTemporarily(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'disableReadonlyModeTemporarily');
    }
    return result as v1DisableReadonlyModeTemporarilyResponseSuccess;
  }

  async setupAReadReplica(ref: string, setUpReadReplicaBody: SetUpReadReplicaBody, options?: RequestInit): Promise<v1SetupAReadReplicaResponseSuccess> {
    const result = await v1SetupAReadReplica(ref, setUpReadReplicaBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'setupAReadReplica');
    }
    return result as v1SetupAReadReplicaResponseSuccess;
  }

  async removeAReadReplica(ref: string, removeReadReplicaBody: RemoveReadReplicaBody, options?: RequestInit): Promise<v1RemoveAReadReplicaResponseSuccess> {
    const result = await v1RemoveAReadReplica(ref, removeReadReplicaBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'removeAReadReplica');
    }
    return result as v1RemoveAReadReplicaResponseSuccess;
  }

  async createLoginRole(ref: string, createRoleBody: CreateRoleBody, options?: RequestInit): Promise<v1CreateLoginRoleResponseSuccess> {
    const result = await v1CreateLoginRole(ref, createRoleBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createLoginRole');
    }
    return result as v1CreateLoginRoleResponseSuccess;
  }

  async deleteLoginRoles(ref: string, options?: RequestInit): Promise<v1DeleteLoginRolesResponseSuccess> {
    const result = await v1DeleteLoginRoles(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteLoginRoles');
    }
    return result as v1DeleteLoginRolesResponseSuccess;
  }

  async listMigrationHistory(ref: string, options?: RequestInit): Promise<v1ListMigrationHistoryResponseSuccess> {
    const result = await v1ListMigrationHistory(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listMigrationHistory');
    }
    return result as v1ListMigrationHistoryResponseSuccess;
  }

  async applyAMigration(ref: string, v1CreateMigrationBody: V1CreateMigrationBody, options?: RequestInit): Promise<v1ApplyAMigrationResponseSuccess> {
    const result = await v1ApplyAMigration(ref, v1CreateMigrationBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'applyAMigration');
    }
    return result as v1ApplyAMigrationResponseSuccess;
  }

  async upsertAMigration(ref: string, v1UpsertMigrationBody: V1UpsertMigrationBody, options?: RequestInit): Promise<v1UpsertAMigrationResponseSuccess> {
    const result = await v1UpsertAMigration(ref, v1UpsertMigrationBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'upsertAMigration');
    }
    return result as v1UpsertAMigrationResponseSuccess;
  }

  async rollbackMigrations(ref: string, params: V1RollbackMigrationsParams, options?: RequestInit): Promise<v1RollbackMigrationsResponseSuccess> {
    const result = await v1RollbackMigrations(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'rollbackMigrations');
    }
    return result as v1RollbackMigrationsResponseSuccess;
  }

  async getAMigration(ref: string, version: string, options?: RequestInit): Promise<v1GetAMigrationResponseSuccess> {
    const result = await v1GetAMigration(ref, version, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getAMigration');
    }
    return result as v1GetAMigrationResponseSuccess;
  }

  async patchAMigration(ref: string, version: string, v1PatchMigrationBody: V1PatchMigrationBody, options?: RequestInit): Promise<v1PatchAMigrationResponseSuccess> {
    const result = await v1PatchAMigration(ref, version, v1PatchMigrationBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'patchAMigration');
    }
    return result as v1PatchAMigrationResponseSuccess;
  }

  async runAQuery(ref: string, v1RunQueryBody: V1RunQueryBody, options?: RequestInit): Promise<v1RunAQueryResponseSuccess> {
    const result = await v1RunAQuery(ref, v1RunQueryBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'runAQuery');
    }
    return result as v1RunAQueryResponseSuccess;
  }

  async readOnlyQuery(ref: string, v1ReadOnlyQueryBody: V1ReadOnlyQueryBody, options?: RequestInit): Promise<v1ReadOnlyQueryResponseSuccess> {
    const result = await v1ReadOnlyQuery(ref, v1ReadOnlyQueryBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'readOnlyQuery');
    }
    return result as v1ReadOnlyQueryResponseSuccess;
  }

  async enableDatabaseWebhook(ref: string, options?: RequestInit): Promise<v1EnableDatabaseWebhookResponseSuccess> {
    const result = await v1EnableDatabaseWebhook(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'enableDatabaseWebhook');
    }
    return result as v1EnableDatabaseWebhookResponseSuccess;
  }

  async getDatabaseMetadata(ref: string, options?: RequestInit): Promise<v1GetDatabaseMetadataResponseSuccess> {
    const result = await v1GetDatabaseMetadata(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getDatabaseMetadata');
    }
    return result as v1GetDatabaseMetadataResponseSuccess;
  }

  async updateDatabasePassword(ref: string, v1UpdatePasswordBody: V1UpdatePasswordBody, options?: RequestInit): Promise<v1UpdateDatabasePasswordResponseSuccess> {
    const result = await v1UpdateDatabasePassword(ref, v1UpdatePasswordBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateDatabasePassword');
    }
    return result as v1UpdateDatabasePasswordResponseSuccess;
  }

  async getJitAccess(ref: string, options?: RequestInit): Promise<v1GetJitAccessResponseSuccess> {
    const result = await v1GetJitAccess(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getJitAccess');
    }
    return result as v1GetJitAccessResponseSuccess;
  }

  async authorizeJitAccess(ref: string, authorizeJitAccessBody: AuthorizeJitAccessBody, options?: RequestInit): Promise<v1AuthorizeJitAccessResponseSuccess> {
    const result = await v1AuthorizeJitAccess(ref, authorizeJitAccessBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'authorizeJitAccess');
    }
    return result as v1AuthorizeJitAccessResponseSuccess;
  }

  async updateJitAccess(ref: string, updateJitAccessBody: UpdateJitAccessBody, options?: RequestInit): Promise<v1UpdateJitAccessResponseSuccess> {
    const result = await v1UpdateJitAccess(ref, updateJitAccessBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateJitAccess');
    }
    return result as v1UpdateJitAccessResponseSuccess;
  }

  async listJitAccess(ref: string, options?: RequestInit): Promise<v1ListJitAccessResponseSuccess> {
    const result = await v1ListJitAccess(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listJitAccess');
    }
    return result as v1ListJitAccessResponseSuccess;
  }

  async deleteJitAccess(ref: string, userId: string, options?: RequestInit): Promise<v1DeleteJitAccessResponseSuccess> {
    const result = await v1DeleteJitAccess(ref, userId, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteJitAccess');
    }
    return result as v1DeleteJitAccessResponseSuccess;
  }

  async getProjectPgbouncerConfig(ref: string, options?: RequestInit): Promise<v1GetProjectPgbouncerConfigResponseSuccess> {
    const result = await v1GetProjectPgbouncerConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectPgbouncerConfig');
    }
    return result as v1GetProjectPgbouncerConfigResponseSuccess;
  }

  async getPoolerConfig(ref: string, options?: RequestInit): Promise<v1GetPoolerConfigResponseSuccess> {
    const result = await v1GetPoolerConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getPoolerConfig');
    }
    return result as v1GetPoolerConfigResponseSuccess;
  }

  async updatePoolerConfig(ref: string, updateSupavisorConfigBody: UpdateSupavisorConfigBody, options?: RequestInit): Promise<v1UpdatePoolerConfigResponseSuccess> {
    const result = await v1UpdatePoolerConfig(ref, updateSupavisorConfigBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updatePoolerConfig');
    }
    return result as v1UpdatePoolerConfigResponseSuccess;
  }

  async getPostgresConfig(ref: string, options?: RequestInit): Promise<v1GetPostgresConfigResponseSuccess> {
    const result = await v1GetPostgresConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getPostgresConfig');
    }
    return result as v1GetPostgresConfigResponseSuccess;
  }

  async updatePostgresConfig(ref: string, updatePostgresConfigBody: UpdatePostgresConfigBody, options?: RequestInit): Promise<v1UpdatePostgresConfigResponseSuccess> {
    const result = await v1UpdatePostgresConfig(ref, updatePostgresConfigBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updatePostgresConfig');
    }
    return result as v1UpdatePostgresConfigResponseSuccess;
  }

  async listAllBackups(ref: string, options?: RequestInit): Promise<v1ListAllBackupsResponseSuccess> {
    const result = await v1ListAllBackups(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllBackups');
    }
    return result as v1ListAllBackupsResponseSuccess;
  }

  async restorePitrBackup(ref: string, v1RestorePitrBody: V1RestorePitrBody, options?: RequestInit): Promise<v1RestorePitrBackupResponseSuccess> {
    const result = await v1RestorePitrBackup(ref, v1RestorePitrBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'restorePitrBackup');
    }
    return result as v1RestorePitrBackupResponseSuccess;
  }

  async createRestorePoint(ref: string, v1RestorePointPostBody: V1RestorePointPostBody, options?: RequestInit): Promise<v1CreateRestorePointResponseSuccess> {
    const result = await v1CreateRestorePoint(ref, v1RestorePointPostBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createRestorePoint');
    }
    return result as v1CreateRestorePointResponseSuccess;
  }

  async getRestorePoint(ref: string, params?: V1GetRestorePointParams, options?: RequestInit): Promise<v1GetRestorePointResponseSuccess> {
    const result = await v1GetRestorePoint(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getRestorePoint');
    }
    return result as v1GetRestorePointResponseSuccess;
  }

  async undo(ref: string, v1UndoBody: V1UndoBody, options?: RequestInit): Promise<v1UndoResponseSuccess> {
    const result = await v1Undo(ref, v1UndoBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'undo');
    }
    return result as v1UndoResponseSuccess;
  }

  async getHostnameConfig(ref: string, options?: RequestInit): Promise<v1GetHostnameConfigResponseSuccess> {
    const result = await v1GetHostnameConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getHostnameConfig');
    }
    return result as v1GetHostnameConfigResponseSuccess;
  }

  async deleteHostnameConfig(ref: string, options?: RequestInit): Promise<v1DeleteHostnameConfigResponseSuccess> {
    const result = await v1DeleteHostnameConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteHostnameConfig');
    }
    return result as v1DeleteHostnameConfigResponseSuccess;
  }

  async updateHostnameConfig(ref: string, updateCustomHostnameBody: UpdateCustomHostnameBody, options?: RequestInit): Promise<v1UpdateHostnameConfigResponseSuccess> {
    const result = await v1UpdateHostnameConfig(ref, updateCustomHostnameBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateHostnameConfig');
    }
    return result as v1UpdateHostnameConfigResponseSuccess;
  }

  async verifyDnsConfig(ref: string, options?: RequestInit): Promise<v1VerifyDnsConfigResponseSuccess> {
    const result = await v1VerifyDnsConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'verifyDnsConfig');
    }
    return result as v1VerifyDnsConfigResponseSuccess;
  }

  async activateCustomHostname(ref: string, options?: RequestInit): Promise<v1ActivateCustomHostnameResponseSuccess> {
    const result = await v1ActivateCustomHostname(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'activateCustomHostname');
    }
    return result as v1ActivateCustomHostnameResponseSuccess;
  }

  async getVanitySubdomainConfig(ref: string, options?: RequestInit): Promise<v1GetVanitySubdomainConfigResponseSuccess> {
    const result = await v1GetVanitySubdomainConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getVanitySubdomainConfig');
    }
    return result as v1GetVanitySubdomainConfigResponseSuccess;
  }

  async deactivateVanitySubdomainConfig(ref: string, options?: RequestInit): Promise<v1DeactivateVanitySubdomainConfigResponseSuccess> {
    const result = await v1DeactivateVanitySubdomainConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deactivateVanitySubdomainConfig');
    }
    return result as v1DeactivateVanitySubdomainConfigResponseSuccess;
  }

  async checkVanitySubdomainAvailability(ref: string, vanitySubdomainBody: VanitySubdomainBody, options?: RequestInit): Promise<v1CheckVanitySubdomainAvailabilityResponseSuccess> {
    const result = await v1CheckVanitySubdomainAvailability(ref, vanitySubdomainBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'checkVanitySubdomainAvailability');
    }
    return result as v1CheckVanitySubdomainAvailabilityResponseSuccess;
  }

  async activateVanitySubdomainConfig(ref: string, vanitySubdomainBody: VanitySubdomainBody, options?: RequestInit): Promise<v1ActivateVanitySubdomainConfigResponseSuccess> {
    const result = await v1ActivateVanitySubdomainConfig(ref, vanitySubdomainBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'activateVanitySubdomainConfig');
    }
    return result as v1ActivateVanitySubdomainConfigResponseSuccess;
  }

  async listAllFunctions(ref: string, options?: RequestInit): Promise<v1ListAllFunctionsResponseSuccess> {
    const result = await v1ListAllFunctions(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllFunctions');
    }
    return result as v1ListAllFunctionsResponseSuccess;
  }

  async createAFunctionWithApplicationVndDenolandEszip(ref: string, v1CreateAFunctionWithApplicationVndDenolandEszipBody: Blob, params?: V1CreateAFunctionWithApplicationVndDenolandEszipParams, options?: RequestInit): Promise<v1CreateAFunctionWithApplicationVndDenolandEszipResponseSuccess> {
    const result = await v1CreateAFunctionWithApplicationVndDenolandEszip(ref, v1CreateAFunctionWithApplicationVndDenolandEszipBody, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createAFunctionWithApplicationVndDenolandEszip');
    }
    return result as v1CreateAFunctionWithApplicationVndDenolandEszipResponseSuccess;
  }

  async createAFunctionWithJson(ref: string, v1CreateFunctionBody: V1CreateFunctionBody, params?: V1CreateAFunctionWithJsonParams, options?: RequestInit): Promise<v1CreateAFunctionWithJsonResponseSuccess> {
    const result = await v1CreateAFunctionWithJson(ref, v1CreateFunctionBody, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createAFunctionWithJson');
    }
    return result as v1CreateAFunctionWithJsonResponseSuccess;
  }

  async bulkUpdateFunctions(ref: string, bulkUpdateFunctionBody: BulkUpdateFunctionBody, options?: RequestInit): Promise<v1BulkUpdateFunctionsResponseSuccess> {
    const result = await v1BulkUpdateFunctions(ref, bulkUpdateFunctionBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'bulkUpdateFunctions');
    }
    return result as v1BulkUpdateFunctionsResponseSuccess;
  }

  async deployAFunction(ref: string, functionDeployBody: FunctionDeployBody, params?: V1DeployAFunctionParams, options?: RequestInit): Promise<v1DeployAFunctionResponseSuccess> {
    const result = await v1DeployAFunction(ref, functionDeployBody, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deployAFunction');
    }
    return result as v1DeployAFunctionResponseSuccess;
  }

  async getAFunction(ref: string, functionSlug: string, options?: RequestInit): Promise<v1GetAFunctionResponseSuccess> {
    const result = await v1GetAFunction(ref, functionSlug, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getAFunction');
    }
    return result as v1GetAFunctionResponseSuccess;
  }

  async updateAFunctionWithApplicationVndDenolandEszip(ref: string, functionSlug: string, v1UpdateAFunctionWithApplicationVndDenolandEszipBody: Blob, params?: V1UpdateAFunctionWithApplicationVndDenolandEszipParams, options?: RequestInit): Promise<v1UpdateAFunctionWithApplicationVndDenolandEszipResponseSuccess> {
    const result = await v1UpdateAFunctionWithApplicationVndDenolandEszip(ref, functionSlug, v1UpdateAFunctionWithApplicationVndDenolandEszipBody, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateAFunctionWithApplicationVndDenolandEszip');
    }
    return result as v1UpdateAFunctionWithApplicationVndDenolandEszipResponseSuccess;
  }

  async updateAFunctionWithJson(ref: string, functionSlug: string, v1UpdateFunctionBody: V1UpdateFunctionBody, params?: V1UpdateAFunctionWithJsonParams, options?: RequestInit): Promise<v1UpdateAFunctionWithJsonResponseSuccess> {
    const result = await v1UpdateAFunctionWithJson(ref, functionSlug, v1UpdateFunctionBody, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateAFunctionWithJson');
    }
    return result as v1UpdateAFunctionWithJsonResponseSuccess;
  }

  async deleteAFunction(ref: string, functionSlug: string, options?: RequestInit): Promise<v1DeleteAFunctionResponseSuccess> {
    const result = await v1DeleteAFunction(ref, functionSlug, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteAFunction');
    }
    return result as v1DeleteAFunctionResponseSuccess;
  }

  async getAFunctionBody(ref: string, functionSlug: string, options?: RequestInit): Promise<v1GetAFunctionBodyResponseSuccess> {
    const result = await v1GetAFunctionBody(ref, functionSlug, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getAFunctionBody');
    }
    return result as v1GetAFunctionBodyResponseSuccess;
  }

  async getABranchConfig(branchIdOrRef: string, options?: RequestInit): Promise<v1GetABranchConfigResponseSuccess> {
    const result = await v1GetABranchConfig(branchIdOrRef, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getABranchConfig');
    }
    return result as v1GetABranchConfigResponseSuccess;
  }

  async updateABranchConfig(branchIdOrRef: string, updateBranchBody: UpdateBranchBody, options?: RequestInit): Promise<v1UpdateABranchConfigResponseSuccess> {
    const result = await v1UpdateABranchConfig(branchIdOrRef, updateBranchBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateABranchConfig');
    }
    return result as v1UpdateABranchConfigResponseSuccess;
  }

  async deleteABranch(branchIdOrRef: string, params?: V1DeleteABranchParams, options?: RequestInit): Promise<v1DeleteABranchResponseSuccess> {
    const result = await v1DeleteABranch(branchIdOrRef, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteABranch');
    }
    return result as v1DeleteABranchResponseSuccess;
  }

  async pushABranch(branchIdOrRef: string, branchActionBody: BranchActionBody, options?: RequestInit): Promise<v1PushABranchResponseSuccess> {
    const result = await v1PushABranch(branchIdOrRef, branchActionBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'pushABranch');
    }
    return result as v1PushABranchResponseSuccess;
  }

  async mergeABranch(branchIdOrRef: string, branchActionBody: BranchActionBody, options?: RequestInit): Promise<v1MergeABranchResponseSuccess> {
    const result = await v1MergeABranch(branchIdOrRef, branchActionBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'mergeABranch');
    }
    return result as v1MergeABranchResponseSuccess;
  }

  async resetABranch(branchIdOrRef: string, branchActionBody: BranchActionBody, options?: RequestInit): Promise<v1ResetABranchResponseSuccess> {
    const result = await v1ResetABranch(branchIdOrRef, branchActionBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'resetABranch');
    }
    return result as v1ResetABranchResponseSuccess;
  }

  async restoreABranch(branchIdOrRef: string, options?: RequestInit): Promise<v1RestoreABranchResponseSuccess> {
    const result = await v1RestoreABranch(branchIdOrRef, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'restoreABranch');
    }
    return result as v1RestoreABranchResponseSuccess;
  }

  async diffABranch(branchIdOrRef: string, params?: V1DiffABranchParams, options?: RequestInit): Promise<v1DiffABranchResponseSuccess> {
    const result = await v1DiffABranch(branchIdOrRef, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'diffABranch');
    }
    return result as v1DiffABranchResponseSuccess;
  }

  async listActionRuns(ref: string, params?: V1ListActionRunsParams, options?: RequestInit): Promise<v1ListActionRunsResponseSuccess> {
    const result = await v1ListActionRuns(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listActionRuns');
    }
    return result as v1ListActionRunsResponseSuccess;
  }

  async countActionRuns(ref: string, options?: RequestInit): Promise<v1CountActionRunsResponseSuccess> {
    const result = await v1CountActionRuns(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'countActionRuns');
    }
    return result as v1CountActionRunsResponseSuccess;
  }

  async getActionRun(ref: string, runId: string, options?: RequestInit): Promise<v1GetActionRunResponseSuccess> {
    const result = await v1GetActionRun(ref, runId, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getActionRun');
    }
    return result as v1GetActionRunResponseSuccess;
  }

  async updateActionRunStatus(ref: string, runId: string, updateRunStatusBody: UpdateRunStatusBody, options?: RequestInit): Promise<v1UpdateActionRunStatusResponseSuccess> {
    const result = await v1UpdateActionRunStatus(ref, runId, updateRunStatusBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateActionRunStatus');
    }
    return result as v1UpdateActionRunStatusResponseSuccess;
  }

  async getActionRunLogs(ref: string, runId: string, options?: RequestInit): Promise<v1GetActionRunLogsResponseSuccess> {
    const result = await v1GetActionRunLogs(ref, runId, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getActionRunLogs');
    }
    return result as v1GetActionRunLogsResponseSuccess;
  }

  async listAllBranches(ref: string, options?: RequestInit): Promise<v1ListAllBranchesResponseSuccess> {
    const result = await v1ListAllBranches(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllBranches');
    }
    return result as v1ListAllBranchesResponseSuccess;
  }

  async createABranch(ref: string, createBranchBody: CreateBranchBody, options?: RequestInit): Promise<v1CreateABranchResponseSuccess> {
    const result = await v1CreateABranch(ref, createBranchBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createABranch');
    }
    return result as v1CreateABranchResponseSuccess;
  }

  async disablePreviewBranching(ref: string, options?: RequestInit): Promise<v1DisablePreviewBranchingResponseSuccess> {
    const result = await v1DisablePreviewBranching(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'disablePreviewBranching');
    }
    return result as v1DisablePreviewBranchingResponseSuccess;
  }

  async getABranch(ref: string, name: string, options?: RequestInit): Promise<v1GetABranchResponseSuccess> {
    const result = await v1GetABranch(ref, name, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getABranch');
    }
    return result as v1GetABranchResponseSuccess;
  }

  async authorizeUser(params: V1AuthorizeUserParams, options?: RequestInit): Promise<v1AuthorizeUserResponseSuccess> {
    const result = await v1AuthorizeUser(params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'authorizeUser');
    }
    return result as v1AuthorizeUserResponseSuccess;
  }

  async exchangeOauthToken(oAuthTokenBody: OAuthTokenBody, options?: RequestInit): Promise<v1ExchangeOauthTokenResponseSuccess> {
    const result = await v1ExchangeOauthToken(oAuthTokenBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'exchangeOauthToken');
    }
    return result as v1ExchangeOauthTokenResponseSuccess;
  }

  async revokeToken(oAuthRevokeTokenBody: OAuthRevokeTokenBody, options?: RequestInit): Promise<v1RevokeTokenResponseSuccess> {
    const result = await v1RevokeToken(oAuthRevokeTokenBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'revokeToken');
    }
    return result as v1RevokeTokenResponseSuccess;
  }

  async oauthAuthorizeProjectClaim(params: V1OauthAuthorizeProjectClaimParams, options?: RequestInit): Promise<v1OauthAuthorizeProjectClaimResponseSuccess> {
    const result = await v1OauthAuthorizeProjectClaim(params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'oauthAuthorizeProjectClaim');
    }
    return result as v1OauthAuthorizeProjectClaimResponseSuccess;
  }

  async listAllOrganizations(options?: RequestInit): Promise<v1ListAllOrganizationsResponseSuccess> {
    const result = await v1ListAllOrganizations({
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllOrganizations');
    }
    return result as v1ListAllOrganizationsResponseSuccess;
  }

  async createAnOrganization(createOrganizationV1: CreateOrganizationV1, options?: RequestInit): Promise<v1CreateAnOrganizationResponseSuccess> {
    const result = await v1CreateAnOrganization(createOrganizationV1, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createAnOrganization');
    }
    return result as v1CreateAnOrganizationResponseSuccess;
  }

  async listOrganizationMembers(slug: string, options?: RequestInit): Promise<v1ListOrganizationMembersResponseSuccess> {
    const result = await v1ListOrganizationMembers(slug, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listOrganizationMembers');
    }
    return result as v1ListOrganizationMembersResponseSuccess;
  }

  async getAnOrganization(slug: string, options?: RequestInit): Promise<v1GetAnOrganizationResponseSuccess> {
    const result = await v1GetAnOrganization(slug, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getAnOrganization');
    }
    return result as v1GetAnOrganizationResponseSuccess;
  }

  async getOrganizationProjectClaim(slug: string, token: string, options?: RequestInit): Promise<v1GetOrganizationProjectClaimResponseSuccess> {
    const result = await v1GetOrganizationProjectClaim(slug, token, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getOrganizationProjectClaim');
    }
    return result as v1GetOrganizationProjectClaimResponseSuccess;
  }

  async claimProjectForOrganization(slug: string, token: string, options?: RequestInit): Promise<v1ClaimProjectForOrganizationResponseSuccess> {
    const result = await v1ClaimProjectForOrganization(slug, token, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'claimProjectForOrganization');
    }
    return result as v1ClaimProjectForOrganizationResponseSuccess;
  }

  async listAllProjects(options?: RequestInit): Promise<v1ListAllProjectsResponseSuccess> {
    const result = await v1ListAllProjects({
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllProjects');
    }
    return result as v1ListAllProjectsResponseSuccess;
  }

  async createAProject(v1CreateProjectBody: V1CreateProjectBody, options?: RequestInit): Promise<v1CreateAProjectResponseSuccess> {
    const result = await v1CreateAProject(v1CreateProjectBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createAProject');
    }
    return result as v1CreateAProjectResponseSuccess;
  }

  async getAvailableRegions(params: V1GetAvailableRegionsParams, options?: RequestInit): Promise<v1GetAvailableRegionsResponseSuccess> {
    const result = await v1GetAvailableRegions(params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getAvailableRegions');
    }
    return result as v1GetAvailableRegionsResponseSuccess;
  }

  async listAllNetworkBans(ref: string, options?: RequestInit): Promise<v1ListAllNetworkBansResponseSuccess> {
    const result = await v1ListAllNetworkBans(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllNetworkBans');
    }
    return result as v1ListAllNetworkBansResponseSuccess;
  }

  async listAllNetworkBansEnriched(ref: string, options?: RequestInit): Promise<v1ListAllNetworkBansEnrichedResponseSuccess> {
    const result = await v1ListAllNetworkBansEnriched(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllNetworkBansEnriched');
    }
    return result as v1ListAllNetworkBansEnrichedResponseSuccess;
  }

  async deleteNetworkBans(ref: string, removeNetworkBanRequest: RemoveNetworkBanRequest, options?: RequestInit): Promise<v1DeleteNetworkBansResponseSuccess> {
    const result = await v1DeleteNetworkBans(ref, removeNetworkBanRequest, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteNetworkBans');
    }
    return result as v1DeleteNetworkBansResponseSuccess;
  }

  async getNetworkRestrictions(ref: string, options?: RequestInit): Promise<v1GetNetworkRestrictionsResponseSuccess> {
    const result = await v1GetNetworkRestrictions(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getNetworkRestrictions');
    }
    return result as v1GetNetworkRestrictionsResponseSuccess;
  }

  async patchNetworkRestrictions(ref: string, networkRestrictionsPatchRequest: NetworkRestrictionsPatchRequest, options?: RequestInit): Promise<v1PatchNetworkRestrictionsResponseSuccess> {
    const result = await v1PatchNetworkRestrictions(ref, networkRestrictionsPatchRequest, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'patchNetworkRestrictions');
    }
    return result as v1PatchNetworkRestrictionsResponseSuccess;
  }

  async updateNetworkRestrictions(ref: string, networkRestrictionsRequest: NetworkRestrictionsRequest, options?: RequestInit): Promise<v1UpdateNetworkRestrictionsResponseSuccess> {
    const result = await v1UpdateNetworkRestrictions(ref, networkRestrictionsRequest, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateNetworkRestrictions');
    }
    return result as v1UpdateNetworkRestrictionsResponseSuccess;
  }

  async getProject(ref: string, options?: RequestInit): Promise<v1GetProjectResponseSuccess> {
    const result = await v1GetProject(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProject');
    }
    return result as v1GetProjectResponseSuccess;
  }

  async deleteAProject(ref: string, options?: RequestInit): Promise<v1DeleteAProjectResponseSuccess> {
    const result = await v1DeleteAProject(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteAProject');
    }
    return result as v1DeleteAProjectResponseSuccess;
  }

  async updateAProject(ref: string, v1UpdateProjectBody: V1UpdateProjectBody, options?: RequestInit): Promise<v1UpdateAProjectResponseSuccess> {
    const result = await v1UpdateAProject(ref, v1UpdateProjectBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateAProject');
    }
    return result as v1UpdateAProjectResponseSuccess;
  }

  async upgradePostgresVersion(ref: string, upgradeDatabaseBody: UpgradeDatabaseBody, options?: RequestInit): Promise<v1UpgradePostgresVersionResponseSuccess> {
    const result = await v1UpgradePostgresVersion(ref, upgradeDatabaseBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'upgradePostgresVersion');
    }
    return result as v1UpgradePostgresVersionResponseSuccess;
  }

  async getPostgresUpgradeEligibility(ref: string, options?: RequestInit): Promise<v1GetPostgresUpgradeEligibilityResponseSuccess> {
    const result = await v1GetPostgresUpgradeEligibility(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getPostgresUpgradeEligibility');
    }
    return result as v1GetPostgresUpgradeEligibilityResponseSuccess;
  }

  async getPostgresUpgradeStatus(ref: string, params?: V1GetPostgresUpgradeStatusParams, options?: RequestInit): Promise<v1GetPostgresUpgradeStatusResponseSuccess> {
    const result = await v1GetPostgresUpgradeStatus(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getPostgresUpgradeStatus');
    }
    return result as v1GetPostgresUpgradeStatusResponseSuccess;
  }

  async getServicesHealth(ref: string, params: V1GetServicesHealthParams, options?: RequestInit): Promise<v1GetServicesHealthResponseSuccess> {
    const result = await v1GetServicesHealth(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getServicesHealth');
    }
    return result as v1GetServicesHealthResponseSuccess;
  }

  async pauseAProject(ref: string, options?: RequestInit): Promise<v1PauseAProjectResponseSuccess> {
    const result = await v1PauseAProject(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'pauseAProject');
    }
    return result as v1PauseAProjectResponseSuccess;
  }

  async listAvailableRestoreVersions(ref: string, options?: RequestInit): Promise<v1ListAvailableRestoreVersionsResponseSuccess> {
    const result = await v1ListAvailableRestoreVersions(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAvailableRestoreVersions');
    }
    return result as v1ListAvailableRestoreVersionsResponseSuccess;
  }

  async restoreAProject(ref: string, options?: RequestInit): Promise<v1RestoreAProjectResponseSuccess> {
    const result = await v1RestoreAProject(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'restoreAProject');
    }
    return result as v1RestoreAProjectResponseSuccess;
  }

  async cancelAProjectRestoration(ref: string, options?: RequestInit): Promise<v1CancelAProjectRestorationResponseSuccess> {
    const result = await v1CancelAProjectRestoration(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'cancelAProjectRestoration');
    }
    return result as v1CancelAProjectRestorationResponseSuccess;
  }

  async getProjectClaimToken(ref: string, options?: RequestInit): Promise<v1GetProjectClaimTokenResponseSuccess> {
    const result = await v1GetProjectClaimToken(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectClaimToken');
    }
    return result as v1GetProjectClaimTokenResponseSuccess;
  }

  async createProjectClaimToken(ref: string, options?: RequestInit): Promise<v1CreateProjectClaimTokenResponseSuccess> {
    const result = await v1CreateProjectClaimToken(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createProjectClaimToken');
    }
    return result as v1CreateProjectClaimTokenResponseSuccess;
  }

  async deleteProjectClaimToken(ref: string, options?: RequestInit): Promise<v1DeleteProjectClaimTokenResponseSuccess> {
    const result = await v1DeleteProjectClaimToken(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteProjectClaimToken');
    }
    return result as v1DeleteProjectClaimTokenResponseSuccess;
  }

  async getDiskUtilization(ref: string, options?: RequestInit): Promise<v1GetDiskUtilizationResponseSuccess> {
    const result = await v1GetDiskUtilization(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getDiskUtilization');
    }
    return result as v1GetDiskUtilizationResponseSuccess;
  }

  async modifyDatabaseDisk(ref: string, diskRequestBody: DiskRequestBody, options?: RequestInit): Promise<v1ModifyDatabaseDiskResponseSuccess> {
    const result = await v1ModifyDatabaseDisk(ref, diskRequestBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'modifyDatabaseDisk');
    }
    return result as v1ModifyDatabaseDiskResponseSuccess;
  }

  async getProjectDiskAutoscaleConfig(ref: string, options?: RequestInit): Promise<v1GetProjectDiskAutoscaleConfigResponseSuccess> {
    const result = await v1GetProjectDiskAutoscaleConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectDiskAutoscaleConfig');
    }
    return result as v1GetProjectDiskAutoscaleConfigResponseSuccess;
  }

  async getAllProjectsForOrganization(slug: string, params?: V1GetAllProjectsForOrganizationParams, options?: RequestInit): Promise<v1GetAllProjectsForOrganizationResponseSuccess> {
    const result = await v1GetAllProjectsForOrganization(slug, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getAllProjectsForOrganization');
    }
    return result as v1GetAllProjectsForOrganizationResponseSuccess;
  }

  async getRealtimeConfig(ref: string, options?: RequestInit): Promise<v1GetRealtimeConfigResponseSuccess> {
    const result = await v1GetRealtimeConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getRealtimeConfig');
    }
    return result as v1GetRealtimeConfigResponseSuccess;
  }

  async updateRealtimeConfig(ref: string, updateRealtimeConfigBody: UpdateRealtimeConfigBody, options?: RequestInit): Promise<v1UpdateRealtimeConfigResponseSuccess> {
    const result = await v1UpdateRealtimeConfig(ref, updateRealtimeConfigBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateRealtimeConfig');
    }
    return result as v1UpdateRealtimeConfigResponseSuccess;
  }

  async shutdownRealtime(ref: string, options?: RequestInit): Promise<v1ShutdownRealtimeResponseSuccess> {
    const result = await v1ShutdownRealtime(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'shutdownRealtime');
    }
    return result as v1ShutdownRealtimeResponseSuccess;
  }

  async getPostgrestServiceConfig(ref: string, options?: RequestInit): Promise<v1GetPostgrestServiceConfigResponseSuccess> {
    const result = await v1GetPostgrestServiceConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getPostgrestServiceConfig');
    }
    return result as v1GetPostgrestServiceConfigResponseSuccess;
  }

  async updatePostgrestServiceConfig(ref: string, v1UpdatePostgrestConfigBody: V1UpdatePostgrestConfigBody, options?: RequestInit): Promise<v1UpdatePostgrestServiceConfigResponseSuccess> {
    const result = await v1UpdatePostgrestServiceConfig(ref, v1UpdatePostgrestConfigBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updatePostgrestServiceConfig');
    }
    return result as v1UpdatePostgrestServiceConfigResponseSuccess;
  }

  async getProjectApiKeys(ref: string, params?: V1GetProjectApiKeysParams, options?: RequestInit): Promise<v1GetProjectApiKeysResponseSuccess> {
    const result = await v1GetProjectApiKeys(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectApiKeys');
    }
    return result as v1GetProjectApiKeysResponseSuccess;
  }

  async createProjectApiKey(ref: string, createApiKeyBody: CreateApiKeyBody, params?: V1CreateProjectApiKeyParams, options?: RequestInit): Promise<v1CreateProjectApiKeyResponseSuccess> {
    const result = await v1CreateProjectApiKey(ref, createApiKeyBody, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'createProjectApiKey');
    }
    return result as v1CreateProjectApiKeyResponseSuccess;
  }

  async getProjectLegacyApiKeys(ref: string, options?: RequestInit): Promise<v1GetProjectLegacyApiKeysResponseSuccess> {
    const result = await v1GetProjectLegacyApiKeys(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectLegacyApiKeys');
    }
    return result as v1GetProjectLegacyApiKeysResponseSuccess;
  }

  async updateProjectLegacyApiKeys(ref: string, params: V1UpdateProjectLegacyApiKeysParams, options?: RequestInit): Promise<v1UpdateProjectLegacyApiKeysResponseSuccess> {
    const result = await v1UpdateProjectLegacyApiKeys(ref, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateProjectLegacyApiKeys');
    }
    return result as v1UpdateProjectLegacyApiKeysResponseSuccess;
  }

  async updateProjectApiKey(ref: string, id: string, updateApiKeyBody: UpdateApiKeyBody, params?: V1UpdateProjectApiKeyParams, options?: RequestInit): Promise<v1UpdateProjectApiKeyResponseSuccess> {
    const result = await v1UpdateProjectApiKey(ref, id, updateApiKeyBody, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateProjectApiKey');
    }
    return result as v1UpdateProjectApiKeyResponseSuccess;
  }

  async getProjectApiKey(ref: string, id: string, params?: V1GetProjectApiKeyParams, options?: RequestInit): Promise<v1GetProjectApiKeyResponseSuccess> {
    const result = await v1GetProjectApiKey(ref, id, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getProjectApiKey');
    }
    return result as v1GetProjectApiKeyResponseSuccess;
  }

  async deleteProjectApiKey(ref: string, id: string, params?: V1DeleteProjectApiKeyParams, options?: RequestInit): Promise<v1DeleteProjectApiKeyResponseSuccess> {
    const result = await v1DeleteProjectApiKey(ref, id, params, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'deleteProjectApiKey');
    }
    return result as v1DeleteProjectApiKeyResponseSuccess;
  }

  async getPgsodiumConfig(ref: string, options?: RequestInit): Promise<v1GetPgsodiumConfigResponseSuccess> {
    const result = await v1GetPgsodiumConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getPgsodiumConfig');
    }
    return result as v1GetPgsodiumConfigResponseSuccess;
  }

  async updatePgsodiumConfig(ref: string, updatePgsodiumConfigBody: UpdatePgsodiumConfigBody, options?: RequestInit): Promise<v1UpdatePgsodiumConfigResponseSuccess> {
    const result = await v1UpdatePgsodiumConfig(ref, updatePgsodiumConfigBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updatePgsodiumConfig');
    }
    return result as v1UpdatePgsodiumConfigResponseSuccess;
  }

  async listAllSecrets(ref: string, options?: RequestInit): Promise<v1ListAllSecretsResponseSuccess> {
    const result = await v1ListAllSecrets(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllSecrets');
    }
    return result as v1ListAllSecretsResponseSuccess;
  }

  async bulkCreateSecrets(ref: string, createSecretBody: CreateSecretBody, options?: RequestInit): Promise<v1BulkCreateSecretsResponseSuccess> {
    const result = await v1BulkCreateSecrets(ref, createSecretBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'bulkCreateSecrets');
    }
    return result as v1BulkCreateSecretsResponseSuccess;
  }

  async bulkDeleteSecrets(ref: string, deleteSecretsBody: DeleteSecretsBody, options?: RequestInit): Promise<v1BulkDeleteSecretsResponseSuccess> {
    const result = await v1BulkDeleteSecrets(ref, deleteSecretsBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'bulkDeleteSecrets');
    }
    return result as v1BulkDeleteSecretsResponseSuccess;
  }

  async listAllBuckets(ref: string, options?: RequestInit): Promise<v1ListAllBucketsResponseSuccess> {
    const result = await v1ListAllBuckets(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'listAllBuckets');
    }
    return result as v1ListAllBucketsResponseSuccess;
  }

  async getStorageConfig(ref: string, options?: RequestInit): Promise<v1GetStorageConfigResponseSuccess> {
    const result = await v1GetStorageConfig(ref, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'getStorageConfig');
    }
    return result as v1GetStorageConfigResponseSuccess;
  }

  async updateStorageConfig(ref: string, updateStorageConfigBody: UpdateStorageConfigBody, options?: RequestInit): Promise<v1UpdateStorageConfigResponseSuccess> {
    const result = await v1UpdateStorageConfig(ref, updateStorageConfigBody, {
      ...options,
      headers: { ...this.authHeader, ...options?.headers },
    }, this.baseUrl);
    if (result.status >= 400) {
      throw new SupabaseManagementAPIError(result, 'updateStorageConfig');
    }
    return result as v1UpdateStorageConfigResponseSuccess;
  }
}
