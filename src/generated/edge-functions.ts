/**
 * Generated by orval v8.4.1 üç∫
 * Do not edit manually.
 * Supabase API (v1)
 * Supabase API generated from the OpenAPI specification.<br>Visit [https://supabase.com/docs](https://supabase.com/docs) for a complete documentation.
 * OpenAPI spec version: 1.0.0
 */
import type {
  BulkUpdateFunctionBody,
  BulkUpdateFunctionResponse,
  DeployFunctionResponse,
  FunctionDeployBody,
  FunctionResponse,
  FunctionSlugResponse,
  StreamableFile,
  V1CreateAFunctionParams,
  V1CreateFunctionBody,
  V1DeployAFunctionParams,
  V1UpdateAFunctionParams,
  V1UpdateFunctionBody
} from './supabaseAPIV1.schemas';

import { customFetch } from '../fetcher';


/**
 * Returns all functions you've previously added to the specified project.
 * @summary List all functions
 */
export type v1ListAllFunctionsResponse200 = {
  data: FunctionResponse[]
  status: 200
}

export type v1ListAllFunctionsResponse401 = {
  data: void
  status: 401
}

export type v1ListAllFunctionsResponse403 = {
  data: void
  status: 403
}

export type v1ListAllFunctionsResponse429 = {
  data: void
  status: 429
}

export type v1ListAllFunctionsResponse500 = {
  data: void
  status: 500
}

export type v1ListAllFunctionsResponseSuccess = (v1ListAllFunctionsResponse200) & {
  headers: Headers;
};
export type v1ListAllFunctionsResponseError = (v1ListAllFunctionsResponse401 | v1ListAllFunctionsResponse403 | v1ListAllFunctionsResponse429 | v1ListAllFunctionsResponse500) & {
  headers: Headers;
};

export type v1ListAllFunctionsResponse = (v1ListAllFunctionsResponseSuccess | v1ListAllFunctionsResponseError)

export const getV1ListAllFunctionsUrl = (ref: string,) => {


  

  return `/v1/projects/${ref}/functions`
}

export const v1ListAllFunctions = async (ref: string, options?: RequestInit): Promise<v1ListAllFunctionsResponse> => {
  
  return customFetch<v1ListAllFunctionsResponse>(getV1ListAllFunctionsUrl(ref),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  

/**
 * This endpoint is deprecated - use the deploy endpoint. Creates a function and adds it to the specified project.
 * @deprecated
 * @summary Create a function
 */
export type v1CreateAFunctionResponse201 = {
  data: FunctionResponse
  status: 201
}

export type v1CreateAFunctionResponse401 = {
  data: void
  status: 401
}

export type v1CreateAFunctionResponse402 = {
  data: void
  status: 402
}

export type v1CreateAFunctionResponse403 = {
  data: void
  status: 403
}

export type v1CreateAFunctionResponse429 = {
  data: void
  status: 429
}

export type v1CreateAFunctionResponse500 = {
  data: void
  status: 500
}

export type v1CreateAFunctionResponseSuccess = (v1CreateAFunctionResponse201) & {
  headers: Headers;
};
export type v1CreateAFunctionResponseError = (v1CreateAFunctionResponse401 | v1CreateAFunctionResponse402 | v1CreateAFunctionResponse403 | v1CreateAFunctionResponse429 | v1CreateAFunctionResponse500) & {
  headers: Headers;
};

export type v1CreateAFunctionResponse = (v1CreateAFunctionResponseSuccess | v1CreateAFunctionResponseError)

export const getV1CreateAFunctionUrl = (ref: string,
    params?: V1CreateAFunctionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/projects/${ref}/functions?${stringifiedParams}` : `/v1/projects/${ref}/functions`
}

export const v1CreateAFunction = async (ref: string,
    v1CreateAFunctionBody: Blob | V1CreateFunctionBody,
    params?: V1CreateAFunctionParams, options?: RequestInit): Promise<v1CreateAFunctionResponse> => {
  
  return customFetch<v1CreateAFunctionResponse>(getV1CreateAFunctionUrl(ref,params),
  {      
    ...options,
    method: 'POST'
    ,
    body: JSON.stringify(
      v1CreateAFunctionBody,)
  }
);}
  

/**
 * Bulk update functions. It will create a new function or replace existing. The operation is idempotent. NOTE: You will need to manually bump the version.
 * @summary Bulk update functions
 */
export type v1BulkUpdateFunctionsResponse200 = {
  data: BulkUpdateFunctionResponse
  status: 200
}

export type v1BulkUpdateFunctionsResponse401 = {
  data: void
  status: 401
}

export type v1BulkUpdateFunctionsResponse402 = {
  data: void
  status: 402
}

export type v1BulkUpdateFunctionsResponse403 = {
  data: void
  status: 403
}

export type v1BulkUpdateFunctionsResponse429 = {
  data: void
  status: 429
}

export type v1BulkUpdateFunctionsResponse500 = {
  data: void
  status: 500
}

export type v1BulkUpdateFunctionsResponseSuccess = (v1BulkUpdateFunctionsResponse200) & {
  headers: Headers;
};
export type v1BulkUpdateFunctionsResponseError = (v1BulkUpdateFunctionsResponse401 | v1BulkUpdateFunctionsResponse402 | v1BulkUpdateFunctionsResponse403 | v1BulkUpdateFunctionsResponse429 | v1BulkUpdateFunctionsResponse500) & {
  headers: Headers;
};

export type v1BulkUpdateFunctionsResponse = (v1BulkUpdateFunctionsResponseSuccess | v1BulkUpdateFunctionsResponseError)

export const getV1BulkUpdateFunctionsUrl = (ref: string,) => {


  

  return `/v1/projects/${ref}/functions`
}

export const v1BulkUpdateFunctions = async (ref: string,
    bulkUpdateFunctionBody: BulkUpdateFunctionBody, options?: RequestInit): Promise<v1BulkUpdateFunctionsResponse> => {
  
  return customFetch<v1BulkUpdateFunctionsResponse>(getV1BulkUpdateFunctionsUrl(ref),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      bulkUpdateFunctionBody,)
  }
);}
  

/**
 * A new endpoint to deploy functions. It will create if function does not exist.
 * @summary Deploy a function
 */
export type v1DeployAFunctionResponse201 = {
  data: DeployFunctionResponse
  status: 201
}

export type v1DeployAFunctionResponse401 = {
  data: void
  status: 401
}

export type v1DeployAFunctionResponse402 = {
  data: void
  status: 402
}

export type v1DeployAFunctionResponse403 = {
  data: void
  status: 403
}

export type v1DeployAFunctionResponse429 = {
  data: void
  status: 429
}

export type v1DeployAFunctionResponse500 = {
  data: void
  status: 500
}

export type v1DeployAFunctionResponseSuccess = (v1DeployAFunctionResponse201) & {
  headers: Headers;
};
export type v1DeployAFunctionResponseError = (v1DeployAFunctionResponse401 | v1DeployAFunctionResponse402 | v1DeployAFunctionResponse403 | v1DeployAFunctionResponse429 | v1DeployAFunctionResponse500) & {
  headers: Headers;
};

export type v1DeployAFunctionResponse = (v1DeployAFunctionResponseSuccess | v1DeployAFunctionResponseError)

export const getV1DeployAFunctionUrl = (ref: string,
    params?: V1DeployAFunctionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/projects/${ref}/functions/deploy?${stringifiedParams}` : `/v1/projects/${ref}/functions/deploy`
}

export const v1DeployAFunction = async (ref: string,
    functionDeployBody: FunctionDeployBody,
    params?: V1DeployAFunctionParams, options?: RequestInit): Promise<v1DeployAFunctionResponse> => {
    const formData = new FormData();
if(functionDeployBody.file !== undefined) {
 functionDeployBody.file.forEach(value => formData.append(`file`, value));
 }
formData.append(`metadata`, JSON.stringify(functionDeployBody.metadata));

  return customFetch<v1DeployAFunctionResponse>(getV1DeployAFunctionUrl(ref,params),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
);}
  

/**
 * Retrieves a function with the specified slug and project.
 * @summary Retrieve a function
 */
export type v1GetAFunctionResponse200 = {
  data: FunctionSlugResponse
  status: 200
}

export type v1GetAFunctionResponse401 = {
  data: void
  status: 401
}

export type v1GetAFunctionResponse403 = {
  data: void
  status: 403
}

export type v1GetAFunctionResponse429 = {
  data: void
  status: 429
}

export type v1GetAFunctionResponse500 = {
  data: void
  status: 500
}

export type v1GetAFunctionResponseSuccess = (v1GetAFunctionResponse200) & {
  headers: Headers;
};
export type v1GetAFunctionResponseError = (v1GetAFunctionResponse401 | v1GetAFunctionResponse403 | v1GetAFunctionResponse429 | v1GetAFunctionResponse500) & {
  headers: Headers;
};

export type v1GetAFunctionResponse = (v1GetAFunctionResponseSuccess | v1GetAFunctionResponseError)

export const getV1GetAFunctionUrl = (ref: string,
    functionSlug: string,) => {


  

  return `/v1/projects/${ref}/functions/${functionSlug}`
}

export const v1GetAFunction = async (ref: string,
    functionSlug: string, options?: RequestInit): Promise<v1GetAFunctionResponse> => {
  
  return customFetch<v1GetAFunctionResponse>(getV1GetAFunctionUrl(ref,functionSlug),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  

/**
 * Updates a function with the specified slug and project.
 * @summary Update a function
 */
export type v1UpdateAFunctionResponse200 = {
  data: FunctionResponse
  status: 200
}

export type v1UpdateAFunctionResponse401 = {
  data: void
  status: 401
}

export type v1UpdateAFunctionResponse403 = {
  data: void
  status: 403
}

export type v1UpdateAFunctionResponse429 = {
  data: void
  status: 429
}

export type v1UpdateAFunctionResponse500 = {
  data: void
  status: 500
}

export type v1UpdateAFunctionResponseSuccess = (v1UpdateAFunctionResponse200) & {
  headers: Headers;
};
export type v1UpdateAFunctionResponseError = (v1UpdateAFunctionResponse401 | v1UpdateAFunctionResponse403 | v1UpdateAFunctionResponse429 | v1UpdateAFunctionResponse500) & {
  headers: Headers;
};

export type v1UpdateAFunctionResponse = (v1UpdateAFunctionResponseSuccess | v1UpdateAFunctionResponseError)

export const getV1UpdateAFunctionUrl = (ref: string,
    functionSlug: string,
    params?: V1UpdateAFunctionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/projects/${ref}/functions/${functionSlug}?${stringifiedParams}` : `/v1/projects/${ref}/functions/${functionSlug}`
}

export const v1UpdateAFunction = async (ref: string,
    functionSlug: string,
    v1UpdateAFunctionBody: Blob | V1UpdateFunctionBody,
    params?: V1UpdateAFunctionParams, options?: RequestInit): Promise<v1UpdateAFunctionResponse> => {
  
  return customFetch<v1UpdateAFunctionResponse>(getV1UpdateAFunctionUrl(ref,functionSlug,params),
  {      
    ...options,
    method: 'PATCH'
    ,
    body: JSON.stringify(
      v1UpdateAFunctionBody,)
  }
);}
  

/**
 * Deletes a function with the specified slug from the specified project.
 * @summary Delete a function
 */
export type v1DeleteAFunctionResponse200 = {
  data: void
  status: 200
}

export type v1DeleteAFunctionResponse401 = {
  data: void
  status: 401
}

export type v1DeleteAFunctionResponse403 = {
  data: void
  status: 403
}

export type v1DeleteAFunctionResponse429 = {
  data: void
  status: 429
}

export type v1DeleteAFunctionResponse500 = {
  data: void
  status: 500
}

export type v1DeleteAFunctionResponseSuccess = (v1DeleteAFunctionResponse200) & {
  headers: Headers;
};
export type v1DeleteAFunctionResponseError = (v1DeleteAFunctionResponse401 | v1DeleteAFunctionResponse403 | v1DeleteAFunctionResponse429 | v1DeleteAFunctionResponse500) & {
  headers: Headers;
};

export type v1DeleteAFunctionResponse = (v1DeleteAFunctionResponseSuccess | v1DeleteAFunctionResponseError)

export const getV1DeleteAFunctionUrl = (ref: string,
    functionSlug: string,) => {


  

  return `/v1/projects/${ref}/functions/${functionSlug}`
}

export const v1DeleteAFunction = async (ref: string,
    functionSlug: string, options?: RequestInit): Promise<v1DeleteAFunctionResponse> => {
  
  return customFetch<v1DeleteAFunctionResponse>(getV1DeleteAFunctionUrl(ref,functionSlug),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
  

/**
 * Retrieves a function body for the specified slug and project.
 * @summary Retrieve a function body
 */
export type v1GetAFunctionBodyResponse200 = {
  data: StreamableFile
  status: 200
}

export type v1GetAFunctionBodyResponse401 = {
  data: void
  status: 401
}

export type v1GetAFunctionBodyResponse403 = {
  data: void
  status: 403
}

export type v1GetAFunctionBodyResponse429 = {
  data: void
  status: 429
}

export type v1GetAFunctionBodyResponse500 = {
  data: void
  status: 500
}

export type v1GetAFunctionBodyResponseSuccess = (v1GetAFunctionBodyResponse200) & {
  headers: Headers;
};
export type v1GetAFunctionBodyResponseError = (v1GetAFunctionBodyResponse401 | v1GetAFunctionBodyResponse403 | v1GetAFunctionBodyResponse429 | v1GetAFunctionBodyResponse500) & {
  headers: Headers;
};

export type v1GetAFunctionBodyResponse = (v1GetAFunctionBodyResponseSuccess | v1GetAFunctionBodyResponseError)

export const getV1GetAFunctionBodyUrl = (ref: string,
    functionSlug: string,) => {


  

  return `/v1/projects/${ref}/functions/${functionSlug}/body`
}

export const v1GetAFunctionBody = async (ref: string,
    functionSlug: string, options?: RequestInit): Promise<v1GetAFunctionBodyResponse> => {
  
  return customFetch<v1GetAFunctionBodyResponse>(getV1GetAFunctionBodyUrl(ref,functionSlug),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}
  

