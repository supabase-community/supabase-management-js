/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * Supabase API (v1)
 * Supabase API generated from the OpenAPI specification.<br>Visit [https://supabase.com/docs](https://supabase.com/docs) for a complete documentation.
 * OpenAPI spec version: 1.0.0
 */
import type {
  OAuthRevokeTokenBody,
  OAuthTokenBody,
  OAuthTokenResponse,
  V1AuthorizeUserParams,
  V1OauthAuthorizeProjectClaimParams
} from './supabaseAPIV1.schemas';

import { customInstance } from '../mutator';



type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];


  export const getOauth = () => {
/**
 * @summary [Beta] Authorize user through oauth
 */
const v1AuthorizeUser = (
    params: V1AuthorizeUserParams,
 options?: SecondParameter<typeof customInstance<void>>,) => {
      return customInstance<void>(
      {url: `/v1/oauth/authorize`, method: 'GET',
        params
    },
      options);
    }
  /**
 * @summary [Beta] Exchange auth code for user's access and refresh token
 */
const v1ExchangeOauthToken = (
    oAuthTokenBody: OAuthTokenBody,
 options?: SecondParameter<typeof customInstance<OAuthTokenResponse>>,) => {const formUrlEncoded = new URLSearchParams();
if(oAuthTokenBody.grant_type !== undefined) {
 formUrlEncoded.append(`grant_type`, oAuthTokenBody.grant_type);
 }
if(oAuthTokenBody.client_id !== undefined) {
 formUrlEncoded.append(`client_id`, oAuthTokenBody.client_id);
 }
if(oAuthTokenBody.client_secret !== undefined) {
 formUrlEncoded.append(`client_secret`, oAuthTokenBody.client_secret);
 }
if(oAuthTokenBody.code !== undefined) {
 formUrlEncoded.append(`code`, oAuthTokenBody.code);
 }
if(oAuthTokenBody.code_verifier !== undefined) {
 formUrlEncoded.append(`code_verifier`, oAuthTokenBody.code_verifier);
 }
if(oAuthTokenBody.redirect_uri !== undefined) {
 formUrlEncoded.append(`redirect_uri`, oAuthTokenBody.redirect_uri);
 }
if(oAuthTokenBody.refresh_token !== undefined) {
 formUrlEncoded.append(`refresh_token`, oAuthTokenBody.refresh_token);
 }
if(oAuthTokenBody.resource !== undefined) {
 formUrlEncoded.append(`resource`, oAuthTokenBody.resource);
 }
if(oAuthTokenBody.scope !== undefined) {
 formUrlEncoded.append(`scope`, oAuthTokenBody.scope);
 }

      return customInstance<OAuthTokenResponse>(
      {url: `/v1/oauth/token`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded
    },
      options);
    }
  /**
 * @summary [Beta] Revoke oauth app authorization and it's corresponding tokens
 */
const v1RevokeToken = (
    oAuthRevokeTokenBody: OAuthRevokeTokenBody,
 options?: SecondParameter<typeof customInstance<void>>,) => {
      return customInstance<void>(
      {url: `/v1/oauth/revoke`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: oAuthRevokeTokenBody
    },
      options);
    }
  /**
 * Initiates the OAuth authorization flow for the specified provider. After successful authentication, the user can claim ownership of the specified project.
 * @summary Authorize user through oauth and claim a project
 */
const v1OauthAuthorizeProjectClaim = (
    params: V1OauthAuthorizeProjectClaimParams,
 options?: SecondParameter<typeof customInstance<void>>,) => {
      return customInstance<void>(
      {url: `/v1/oauth/authorize/project-claim`, method: 'GET',
        params
    },
      options);
    }
  return {v1AuthorizeUser,v1ExchangeOauthToken,v1RevokeToken,v1OauthAuthorizeProjectClaim}};
export type V1AuthorizeUserResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOauth>['v1AuthorizeUser']>>>
export type V1ExchangeOauthTokenResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOauth>['v1ExchangeOauthToken']>>>
export type V1RevokeTokenResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOauth>['v1RevokeToken']>>>
export type V1OauthAuthorizeProjectClaimResult = NonNullable<Awaited<ReturnType<ReturnType<typeof getOauth>['v1OauthAuthorizeProjectClaim']>>>
