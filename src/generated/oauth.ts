/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * Supabase API (v1)
 * Supabase API generated from the OpenAPI specification.<br>Visit [https://supabase.com/docs](https://supabase.com/docs) for a complete documentation.
 * OpenAPI spec version: 1.0.0
 */
import type {
  OAuthRevokeTokenBody,
  OAuthTokenBody,
  OAuthTokenResponse,
  V1AuthorizeUserParams,
  V1OauthAuthorizeProjectClaimParams
} from './supabaseAPIV1.schemas';

import { customFetch } from '../fetcher';


/**
 * @summary [Beta] Authorize user through oauth
 */
export type v1AuthorizeUserResponse204 = {
  data: void
  status: 204
}

export type v1AuthorizeUserResponseSuccess = (v1AuthorizeUserResponse204) & {
  headers: Headers;
};
;

export type v1AuthorizeUserResponse = (v1AuthorizeUserResponseSuccess)

export const getV1AuthorizeUserUrl = (params: V1AuthorizeUserParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/oauth/authorize?${stringifiedParams}` : `/v1/oauth/authorize`
}

export const v1AuthorizeUser = async (params: V1AuthorizeUserParams, options?: RequestInit): Promise<v1AuthorizeUserResponse> => {
  
  return customFetch<v1AuthorizeUserResponse>(getV1AuthorizeUserUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * @summary [Beta] Exchange auth code for user's access and refresh token
 */
export type v1ExchangeOauthTokenResponse201 = {
  data: OAuthTokenResponse
  status: 201
}

export type v1ExchangeOauthTokenResponseSuccess = (v1ExchangeOauthTokenResponse201) & {
  headers: Headers;
};
;

export type v1ExchangeOauthTokenResponse = (v1ExchangeOauthTokenResponseSuccess)

export const getV1ExchangeOauthTokenUrl = () => {


  

  return `/v1/oauth/token`
}

export const v1ExchangeOauthToken = async (oAuthTokenBody: OAuthTokenBody, options?: RequestInit): Promise<v1ExchangeOauthTokenResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(oAuthTokenBody.grant_type !== undefined) {
 formUrlEncoded.append(`grant_type`, oAuthTokenBody.grant_type);
 }
if(oAuthTokenBody.client_id !== undefined) {
 formUrlEncoded.append(`client_id`, oAuthTokenBody.client_id);
 }
if(oAuthTokenBody.client_secret !== undefined) {
 formUrlEncoded.append(`client_secret`, oAuthTokenBody.client_secret);
 }
if(oAuthTokenBody.code !== undefined) {
 formUrlEncoded.append(`code`, oAuthTokenBody.code);
 }
if(oAuthTokenBody.code_verifier !== undefined) {
 formUrlEncoded.append(`code_verifier`, oAuthTokenBody.code_verifier);
 }
if(oAuthTokenBody.redirect_uri !== undefined) {
 formUrlEncoded.append(`redirect_uri`, oAuthTokenBody.redirect_uri);
 }
if(oAuthTokenBody.refresh_token !== undefined) {
 formUrlEncoded.append(`refresh_token`, oAuthTokenBody.refresh_token);
 }
if(oAuthTokenBody.resource !== undefined) {
 formUrlEncoded.append(`resource`, oAuthTokenBody.resource);
 }
if(oAuthTokenBody.scope !== undefined) {
 formUrlEncoded.append(`scope`, oAuthTokenBody.scope);
 }

  return customFetch<v1ExchangeOauthTokenResponse>(getV1ExchangeOauthTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
);}


/**
 * @summary [Beta] Revoke oauth app authorization and it's corresponding tokens
 */
export type v1RevokeTokenResponse204 = {
  data: void
  status: 204
}

export type v1RevokeTokenResponseSuccess = (v1RevokeTokenResponse204) & {
  headers: Headers;
};
;

export type v1RevokeTokenResponse = (v1RevokeTokenResponseSuccess)

export const getV1RevokeTokenUrl = () => {


  

  return `/v1/oauth/revoke`
}

export const v1RevokeToken = async (oAuthRevokeTokenBody: OAuthRevokeTokenBody, options?: RequestInit): Promise<v1RevokeTokenResponse> => {
  
  return customFetch<v1RevokeTokenResponse>(getV1RevokeTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      oAuthRevokeTokenBody,)
  }
);}


/**
 * Initiates the OAuth authorization flow for the specified provider. After successful authentication, the user can claim ownership of the specified project.
 * @summary Authorize user through oauth and claim a project
 */
export type v1OauthAuthorizeProjectClaimResponse204 = {
  data: void
  status: 204
}

export type v1OauthAuthorizeProjectClaimResponseSuccess = (v1OauthAuthorizeProjectClaimResponse204) & {
  headers: Headers;
};
;

export type v1OauthAuthorizeProjectClaimResponse = (v1OauthAuthorizeProjectClaimResponseSuccess)

export const getV1OauthAuthorizeProjectClaimUrl = (params: V1OauthAuthorizeProjectClaimParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/v1/oauth/authorize/project-claim?${stringifiedParams}` : `/v1/oauth/authorize/project-claim`
}

export const v1OauthAuthorizeProjectClaim = async (params: V1OauthAuthorizeProjectClaimParams, options?: RequestInit): Promise<v1OauthAuthorizeProjectClaimResponse> => {
  
  return customFetch<v1OauthAuthorizeProjectClaimResponse>(getV1OauthAuthorizeProjectClaimUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


