import { readdirSync, readFileSync, writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = join(__dirname, "..");
const GENERATED_DIR = join(ROOT, "src", "generated");
const OUT_CLASS = join(ROOT, "src", "api.ts");
const OUT_INDEX = join(ROOT, "src", "index.ts");

// Types that are DOM/JS globals and don't need to be imported
const DOM_GLOBALS = new Set([
  "Blob",
  "FormData",
  "File",
  "Headers",
  "Request",
  "Response",
  "RequestInit",
  "URLSearchParams",
]);

// Primitive types that don't need to be imported
const PRIMITIVES = new Set([
  "string",
  "number",
  "boolean",
  "void",
  "null",
  "undefined",
  "any",
  "unknown",
  "never",
  "object",
]);

/**
 * Splits a comma-separated param string while respecting angle bracket depth
 * (handles generic types like Record<string, string>)
 */
function splitParams(rawParams) {
  const normalized = rawParams.replace(/\s+/g, " ").trim();
  if (!normalized) return [];
  const parts = [];
  let depth = 0;
  let current = "";
  for (const ch of normalized) {
    if (ch === "<") depth++;
    else if (ch === ">") depth--;
    else if (ch === "," && depth === 0) {
      if (current.trim()) parts.push(current.trim());
      current = "";
      continue;
    }
    current += ch;
  }
  if (current.trim()) parts.push(current.trim());
  return parts;
}

/** Extracts the parameter name from a "name: Type" or "name?: Type" string */
function extractParamName(paramStr) {
  return paramStr.split(":")[0].replace("?", "").trim();
}

/** Converts "v1FooBarBaz" to "fooBarBaz" */
function toMethodName(v1Name) {
  const s = v1Name.replace(/^v1/, "");
  return s.charAt(0).toLowerCase() + s.slice(1);
}

/**
 * Collects PascalCase type names from a param string,
 * skipping primitives and DOM globals.
 */
function collectTypeNames(paramStr, typeNames) {
  // Match the type part after ": " — handles optional "?" before the type
  const typeMatch = paramStr.match(/:\s*\??([A-Za-z][A-Za-z0-9]*)/);
  if (!typeMatch) return;
  const typeName = typeMatch[1];
  // Only collect PascalCase types (uppercase first letter)
  if (
    /^[A-Z]/.test(typeName) &&
    !DOM_GLOBALS.has(typeName) &&
    !PRIMITIVES.has(typeName)
  ) {
    typeNames.add(typeName);
  }
}

// Regex to capture v1* async function signatures (handles multi-line params)
const FUNC_REGEX = /^export const (v1[A-Za-z]+) = async \(([\s\S]*?)\): Promise/gm;

const sourceFiles = readdirSync(GENERATED_DIR)
  .filter(
    (f) =>
      f.endsWith(".ts") &&
      f !== "index.ts" &&
      f !== "supabaseAPIV1.schemas.ts"
  )
  .sort();

const methodSpecs = [];
const allFuncNames = [];
const allTypeNames = new Set();
const allResponseTypeNames = new Set();

for (const file of sourceFiles) {
  const text = readFileSync(join(GENERATED_DIR, file), "utf8");
  let match;
  FUNC_REGEX.lastIndex = 0;
  while ((match = FUNC_REGEX.exec(text)) !== null) {
    const [, funcName, rawParams] = match;
    allFuncNames.push(funcName);

    const allParams = splitParams(rawParams);

    // Last param is always "options?: RequestInit" — slice it off
    const nonOptionParams =
      allParams.length === 1 && allParams[0].includes("RequestInit")
        ? []
        : allParams.slice(0, -1);

    const callParams = nonOptionParams.map(extractParamName);
    const methodParamList = nonOptionParams.join(", ");

    // Collect type names from non-options params
    for (const p of nonOptionParams) {
      collectTypeNames(p, allTypeNames);
    }

    const returnType = `${funcName}Response`;
    allResponseTypeNames.add(returnType);

    methodSpecs.push({
      methodName: toMethodName(funcName),
      funcName,
      methodParamList,
      callParams,
      returnType,
    });
  }
}

// Generate class methods
function generateMethod({ methodName, funcName, methodParamList, callParams, returnType }) {
  const signatureParams = methodParamList
    ? `${methodParamList}, options?: RequestInit`
    : `options?: RequestInit`;

  const callArgs =
    callParams.length > 0 ? `${callParams.join(", ")}, ` : "";

  return [
    `  ${methodName}(${signatureParams}): Promise<${returnType}> {`,
    `    return ${funcName}(${callArgs}{`,
    `      ...options,`,
    `      headers: { ...this.authHeader, ...options?.headers },`,
    `    });`,
    `  }`,
  ].join("\n");
}

// Build class file content
const funcImportLines = [...allFuncNames]
  .sort()
  .map((n) => `  ${n},`)
  .join("\n");

const typeImportLines = [...allTypeNames, ...allResponseTypeNames]
  .sort()
  .map((t) => `  ${t},`)
  .join("\n");

const methodBodies = methodSpecs.map(generateMethod).join("\n\n");

const classContent = `\
/**
 * This file is auto-generated by scripts/generate-class.mjs.
 * Do not edit manually - re-run \`npm run generate:client\` to update.
 */
import {
${funcImportLines}
} from './generated';

import type {
${typeImportLines}
} from './generated';

export class SupabaseManagementAPI {
  private readonly accessToken: string;

  constructor(accessToken: string) {
    this.accessToken = accessToken;
  }

  private get authHeader(): HeadersInit {
    return { Authorization: \`Bearer \${this.accessToken}\` };
  }

${methodBodies}
}
`;

writeFileSync(OUT_CLASS, classContent, "utf8");
console.log(
  `Generated src/api.ts (${methodSpecs.length} methods)`
);

// Build index file content
const indexContent = `\
/**
 * This file is auto-generated by scripts/generate-class.mjs.
 * Do not edit manually - re-run \`npm run generate:client\` to update.
 */
export * from './generated';
export { SupabaseManagementAPI } from './api';
`;

writeFileSync(OUT_INDEX, indexContent, "utf8");
console.log("Generated src/index.ts");
